"""
Solution Generator for AI Gatekeeper System
Extends ResearchAgent capabilities for intelligent support solution generation
"""

import sys
import os
import json
import asyncio
from typing import Dict, Any, List, Optional, Union
from datetime import datetime
from dataclasses import dataclass
from enum import Enum

# Add shared agents to Python path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'shared_agents'))

from shared_agents.core.agent_factory import AgentBase, AgentResponse, AgentCapability


class SolutionType(Enum):
    """Types of solutions that can be generated."""
    STEP_BY_STEP = "step_by_step"
    TROUBLESHOOTING = "troubleshooting"
    CONFIGURATION = "configuration"
    DOCUMENTATION = "documentation"
    ESCALATION = "escalation"


class SolutionComplexity(Enum):
    """Complexity levels for solutions."""
    SIMPLE = "simple"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


@dataclass
class SolutionStep:
    """Individual step in a solution."""
    step_number: int
    title: str
    description: str
    commands: List[str] = None
    expected_result: str = ""
    troubleshooting: str = ""
    risk_level: str = "low"  # low, medium, high
    
    def __post_init__(self):
        if self.commands is None:
            self.commands = []


@dataclass
class GeneratedSolution:
    """Complete solution generated by the system."""
    id: str
    issue_description: str
    solution_type: SolutionType
    complexity: SolutionComplexity
    title: str
    summary: str
    steps: List[SolutionStep]
    estimated_time: str
    prerequisites: List[str]
    warnings: List[str]
    related_docs: List[str]
    confidence_score: float
    success_rate: float
    generated_at: datetime
    metadata: Dict[str, Any]
    
    def __post_init__(self):
        if not self.steps:
            self.steps = []
        if not self.prerequisites:
            self.prerequisites = []
        if not self.warnings:
            self.warnings = []
        if not self.related_docs:
            self.related_docs = []
        if not self.metadata:
            self.metadata = {}


class KnowledgeBaseSolutionGenerator:
    """
    Advanced solution generator that leverages existing ResearchAgent capabilities
    and integrates with the vector database for intelligent solution creation.
    """
    
    def __init__(self, agent_manager=None, search_system=None):
        """Initialize the solution generator."""
        self.agent_manager = agent_manager
        self.search_system = search_system
        
        # Solution templates and patterns
        self.solution_templates = self._load_solution_templates()
        self.common_solutions = self._load_common_solutions()
        
        # Knowledge base categories
        self.knowledge_categories = [
            'technical_solutions',
            'troubleshooting_guides',
            'configuration_guides',
            'user_documentation',
            'escalation_procedures',
            'best_practices'
        ]
    
    async def generate_solution(self, 
                              issue_description: str, 
                              user_context: Dict[str, Any],
                              solution_type: Optional[SolutionType] = None) -> GeneratedSolution:
        """
        Generate a comprehensive solution for the given issue.
        
        Args:
            issue_description: Description of the issue to solve
            user_context: Context about the user and environment
            solution_type: Optional specific type of solution requested
            
        Returns:
            GeneratedSolution object with complete solution
        """
        # Step 1: Analyze the issue and determine solution type
        if not solution_type:
            solution_type = await self._determine_solution_type(issue_description)
        
        # Step 2: Search knowledge base for relevant solutions
        knowledge_results = await self._search_knowledge_base(issue_description, user_context)
        
        # Step 3: Generate solution using ResearchAgent
        solution_content = await self._generate_solution_content(
            issue_description, 
            user_context, 
            knowledge_results,
            solution_type
        )
        
        # Step 4: Structure the solution
        structured_solution = await self._structure_solution(
            solution_content,
            issue_description,
            user_context,
            solution_type
        )
        
        # Step 5: Enhance with additional context
        enhanced_solution = await self._enhance_solution(structured_solution, user_context)
        
        return enhanced_solution
    
    async def _determine_solution_type(self, issue_description: str) -> SolutionType:
        """Determine the most appropriate solution type for the issue."""
        description_lower = issue_description.lower()
        
        # Check for troubleshooting indicators
        troubleshooting_keywords = [
            'not working', 'error', 'problem', 'issue', 'broken', 'failing',
            'crash', 'freeze', 'slow', 'timeout', 'connection'
        ]
        
        if any(keyword in description_lower for keyword in troubleshooting_keywords):
            return SolutionType.TROUBLESHOOTING
        
        # Check for configuration indicators
        config_keywords = [
            'setup', 'configure', 'install', 'settings', 'preferences',
            'options', 'parameters', 'environment'
        ]
        
        if any(keyword in description_lower for keyword in config_keywords):
            return SolutionType.CONFIGURATION
        
        # Check for how-to indicators
        howto_keywords = [
            'how to', 'how do i', 'how can i', 'steps to', 'guide',
            'tutorial', 'instructions'
        ]
        
        if any(keyword in description_lower for keyword in howto_keywords):
            return SolutionType.STEP_BY_STEP
        
        # Check for documentation requests
        doc_keywords = [
            'documentation', 'manual', 'reference', 'specification',
            'api', 'examples', 'samples'
        ]
        
        if any(keyword in description_lower for keyword in doc_keywords):
            return SolutionType.DOCUMENTATION
        
        # Default to step-by-step for general issues
        return SolutionType.STEP_BY_STEP
    
    async def _search_knowledge_base(self, 
                                   issue_description: str, 
                                   user_context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Search the knowledge base for relevant solutions."""
        if not self.search_system:
            return []
        
        try:
            # Search across all knowledge categories
            all_results = []
            
            for category in self.knowledge_categories:
                # Use existing search system
                search_results = await self.search_system.assisted_search(
                    vector_store_ids=[category],
                    query=issue_description,
                    num_results=5
                )
                
                if search_results:
                    for result in search_results:
                        result['category'] = category
                        all_results.append(result)
            
            # Rank results by relevance
            ranked_results = self._rank_search_results(all_results, issue_description)
            
            return ranked_results[:10]  # Return top 10 results
            
        except Exception as e:
            print(f"Knowledge base search error: {e}")
            return []
    
    async def _generate_solution_content(self,
                                       issue_description: str,
                                       user_context: Dict[str, Any],
                                       knowledge_results: List[Dict[str, Any]],
                                       solution_type: SolutionType) -> Dict[str, Any]:
        """Generate solution content using ResearchAgent."""
        if not self.agent_manager:
            return self._generate_fallback_solution(issue_description, solution_type)
        
        # Prepare comprehensive input for ResearchAgent
        research_input = {
            'query': issue_description,
            'context': user_context,
            'search_type': 'solution_generation',
            'knowledge_base_results': knowledge_results,
            'solution_type': solution_type.value,
            'requirements': {
                'include_steps': True,
                'include_troubleshooting': True,
                'include_prerequisites': True,
                'include_warnings': True,
                'user_level': user_context.get('user_level', 'intermediate')
            }
        }
        
        try:
            # Execute ResearchAgent for solution generation
            research_response = await self.agent_manager.execute_agent('research', research_input)
            
            if research_response.success:
                return research_response.result
            else:
                print(f"ResearchAgent execution failed: {research_response.error}")
                return self._generate_fallback_solution(issue_description, solution_type)
                
        except Exception as e:
            print(f"Solution generation error: {e}")
            return self._generate_fallback_solution(issue_description, solution_type)
    
    async def _structure_solution(self,
                                solution_content: Dict[str, Any],
                                issue_description: str,
                                user_context: Dict[str, Any],
                                solution_type: SolutionType) -> GeneratedSolution:
        """Structure the solution content into a standardized format."""
        import uuid
        
        # Extract or generate solution components
        title = solution_content.get('title', f"Solution for: {issue_description[:50]}...")
        summary = solution_content.get('summary', 'Generated solution based on knowledge base analysis')
        
        # Parse steps
        steps = []
        raw_steps = solution_content.get('steps', [])
        
        for i, step_data in enumerate(raw_steps, 1):
            if isinstance(step_data, dict):
                step = SolutionStep(
                    step_number=i,
                    title=step_data.get('title', f'Step {i}'),
                    description=step_data.get('description', ''),
                    commands=step_data.get('commands', []),
                    expected_result=step_data.get('expected_result', ''),
                    troubleshooting=step_data.get('troubleshooting', ''),
                    risk_level=step_data.get('risk_level', 'low')
                )
            else:
                # Handle string-based steps
                step = SolutionStep(
                    step_number=i,
                    title=f'Step {i}',
                    description=str(step_data),
                    commands=[],
                    expected_result='',
                    troubleshooting='',
                    risk_level='low'
                )
            steps.append(step)
        
        # Determine complexity based on user level and step count
        complexity = self._determine_complexity(steps, user_context)
        
        # Calculate confidence score
        confidence_score = self._calculate_solution_confidence(solution_content, user_context)
        
        # Create structured solution
        solution = GeneratedSolution(
            id=str(uuid.uuid4()),
            issue_description=issue_description,
            solution_type=solution_type,
            complexity=complexity,
            title=title,
            summary=summary,
            steps=steps,
            estimated_time=solution_content.get('estimated_time', '10-15 minutes'),
            prerequisites=solution_content.get('prerequisites', []),
            warnings=solution_content.get('warnings', []),
            related_docs=solution_content.get('related_docs', []),
            confidence_score=confidence_score,
            success_rate=solution_content.get('success_rate', 0.8),
            generated_at=datetime.now(),
            metadata={
                'solution_type': solution_type.value,
                'user_context': user_context,
                'generation_method': 'ai_research_agent'
            }
        )
        
        return solution
    
    async def _enhance_solution(self, solution: GeneratedSolution, user_context: Dict[str, Any]) -> GeneratedSolution:
        """Enhance the solution with additional context and safety measures."""
        # Add user-specific enhancements
        user_level = user_context.get('user_level', 'intermediate')
        
        if user_level == 'beginner':
            # Add more detailed explanations for beginners
            solution.warnings.append("Take your time with each step and don't hesitate to ask for help if needed.")
            solution.prerequisites.append("Basic familiarity with the system interface")
            
        elif user_level == 'advanced':
            # Add advanced tips and alternatives
            solution.metadata['advanced_tips'] = [
                "Consider automating these steps if this is a recurring issue",
                "Check system logs for additional troubleshooting information"
            ]
        
        # Add safety warnings for high-risk operations
        high_risk_steps = [step for step in solution.steps if step.risk_level == 'high']
        if high_risk_steps:
            solution.warnings.insert(0, "⚠️ This solution contains high-risk operations. Please review carefully before proceeding.")
        
        # Add estimated time adjustments based on complexity
        if solution.complexity == SolutionComplexity.ADVANCED:
            solution.estimated_time = solution.estimated_time.replace('10-15 minutes', '20-30 minutes')
        elif solution.complexity == SolutionComplexity.SIMPLE:
            solution.estimated_time = solution.estimated_time.replace('10-15 minutes', '5-10 minutes')
        
        return solution
    
    def _determine_complexity(self, steps: List[SolutionStep], user_context: Dict[str, Any]) -> SolutionComplexity:
        """Determine the complexity level of the solution."""
        if len(steps) <= 3:
            return SolutionComplexity.SIMPLE
        
        # Check for complex operations
        complex_indicators = ['command line', 'terminal', 'registry', 'configuration file', 'api']
        
        for step in steps:
            step_text = (step.title + ' ' + step.description).lower()
            if any(indicator in step_text for indicator in complex_indicators):
                return SolutionComplexity.ADVANCED
        
        # Check for high-risk steps
        high_risk_steps = [step for step in steps if step.risk_level == 'high']
        if high_risk_steps:
            return SolutionComplexity.ADVANCED
        
        return SolutionComplexity.INTERMEDIATE
    
    def _calculate_solution_confidence(self, solution_content: Dict[str, Any], user_context: Dict[str, Any]) -> float:
        """Calculate confidence score for the generated solution."""
        base_confidence = 0.7
        
        # Boost confidence if solution has detailed steps
        if solution_content.get('steps') and len(solution_content['steps']) > 0:
            base_confidence += 0.1
        
        # Boost confidence if solution includes troubleshooting
        if any('troubleshooting' in step for step in solution_content.get('steps', [])):
            base_confidence += 0.1
        
        # Boost confidence if prerequisites are specified
        if solution_content.get('prerequisites'):
            base_confidence += 0.05
        
        # Adjust for user level
        user_level = user_context.get('user_level', 'intermediate')
        if user_level == 'advanced':
            base_confidence += 0.05
        elif user_level == 'beginner':
            base_confidence -= 0.05
        
        return max(0.0, min(1.0, base_confidence))
    
    def _rank_search_results(self, results: List[Dict[str, Any]], query: str) -> List[Dict[str, Any]]:
        """Rank search results by relevance to the query."""
        # Simple ranking based on keyword overlap
        query_words = set(query.lower().split())
        
        for result in results:
            content = result.get('content', '') + ' ' + result.get('title', '')
            content_words = set(content.lower().split())
            
            # Calculate overlap score
            overlap = len(query_words & content_words)
            total_words = len(query_words)
            
            relevance_score = overlap / total_words if total_words > 0 else 0
            result['relevance_score'] = relevance_score
        
        # Sort by relevance score
        return sorted(results, key=lambda x: x.get('relevance_score', 0), reverse=True)
    
    def _generate_fallback_solution(self, issue_description: str, solution_type: SolutionType) -> Dict[str, Any]:
        """Generate a basic fallback solution when AI generation fails."""
        return {
            'title': f"Basic Solution for: {issue_description[:50]}...",
            'summary': 'This is a basic solution generated from templates.',
            'steps': [
                {
                    'title': 'Identify the Issue',
                    'description': 'Clearly define the problem you are experiencing.',
                    'commands': [],
                    'expected_result': 'Clear understanding of the issue',
                    'troubleshooting': 'If unclear, gather more information about the problem.',
                    'risk_level': 'low'
                },
                {
                    'title': 'Research Solutions',
                    'description': 'Look for existing solutions or documentation.',
                    'commands': [],
                    'expected_result': 'Relevant information found',
                    'troubleshooting': 'Try different search terms or contact support.',
                    'risk_level': 'low'
                },
                {
                    'title': 'Apply Solution',
                    'description': 'Implement the recommended solution carefully.',
                    'commands': [],
                    'expected_result': 'Issue resolved',
                    'troubleshooting': 'If not resolved, escalate to human support.',
                    'risk_level': 'medium'
                }
            ],
            'estimated_time': '15-20 minutes',
            'prerequisites': ['System access', 'Basic troubleshooting knowledge'],
            'warnings': ['Always backup important data before making changes'],
            'related_docs': [],
            'success_rate': 0.6
        }
    
    def _load_solution_templates(self) -> Dict[str, Any]:
        """Load solution templates for common issue types."""
        return {
            'password_reset': {
                'title': 'Password Reset Guide',
                'steps': [
                    'Navigate to login page',
                    'Click "Forgot Password" link',
                    'Enter your email address',
                    'Check email for reset instructions',
                    'Follow the reset link and create new password'
                ]
            },
            'software_installation': {
                'title': 'Software Installation Guide',
                'steps': [
                    'Download the software from official source',
                    'Verify system requirements',
                    'Run the installer with administrator privileges',
                    'Follow installation wizard prompts',
                    'Restart system if required'
                ]
            },
            'connectivity_issues': {
                'title': 'Connectivity Troubleshooting',
                'steps': [
                    'Check physical connections',
                    'Restart network devices',
                    'Verify network settings',
                    'Test with different device',
                    'Contact network administrator if needed'
                ]
            }
        }
    
    def _load_common_solutions(self) -> Dict[str, Any]:
        """Load common solutions for frequently encountered issues."""
        return {
            'login_problems': {
                'confidence': 0.9,
                'solutions': [
                    'Check username and password',
                    'Clear browser cache and cookies',
                    'Try incognito/private browsing mode',
                    'Reset password if necessary'
                ]
            },
            'performance_issues': {
                'confidence': 0.8,
                'solutions': [
                    'Restart the application',
                    'Close unnecessary programs',
                    'Check system resources',
                    'Update software to latest version'
                ]
            },
            'file_access_errors': {
                'confidence': 0.85,
                'solutions': [
                    'Check file permissions',
                    'Verify file location',
                    'Restart application',
                    'Check disk space'
                ]
            }
        }
    
    def get_solution_by_id(self, solution_id: str) -> Optional[GeneratedSolution]:
        """Retrieve a solution by its ID (implement caching if needed)."""
        # This would typically interact with a solution cache or database
        # For now, return None as solutions are generated on-demand
        return None
    
    def get_solution_feedback(self, solution_id: str, feedback: Dict[str, Any]) -> None:
        """Process feedback on a solution for learning purposes."""
        # This would typically store feedback for continuous improvement
        # Implementation depends on your feedback storage system
        pass